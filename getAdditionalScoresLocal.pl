#!/usr/bin/perl -w

# FABRIZIO-style clustering approach
# take score-list from RNAclust and generate center and width matrices
# !! local version !! (deals with local alignment format)

use FindBin;
use lib "$FindBin::Bin";

use strict;
use Getopt::Long;
use Data::Dumper;
use Math::Round;

# contribution to local clustering
# create "center" and "width" matrix for local clustering
# these two features contribute to the overall score

my $usage = << "JUS";
  usage: perl $0 -paligs FILE -n INT -outc FILE -outw FILE

  options:
        -paligs
                directory of pairwise alignments, as generated by RNAclust
                [REQUIRED]

                Format:
                \@99 HIT 21 214 32 255 75

                	+214
                	+32

                15                 GGCUGCUGUUUGUGUUUUGAUUAUUGUUAAAA--GGCUGGGCAG
                8                  GGUCGAUGCUAAUGGUCAGAUUUGUGUCUGACACAAUUUGGCAU

	                +255
	                +75

        -n      Number of sequences in the screen
                [REQUIRED]

        -s      File containing sequences, necessary to get lengths
                [required]

        -outl
                Output file containing the matrix of locarna scores
                [OPTIONAL, default: matrix.locarna]

        -outc
                Output file containing the matrix of centers
                [OPTIONAL, default: matrix.centers]

        -outw
                Output file containing the matrix of widths
                [OPTIONAL, default: matrix.widths]

        -v
                Switch to turn on verbose mode
                [OPTIONAL, default: off]

  purpose: create feature matrices
JUS

my ( $opt_paligs, $opt_n, $opt_outc, $opt_outw, $opt_outl, $opt_v, $opt_s ) =
  ( '', 0, 'matrix.centers', 'matrix.widths', 'matrix.locarna', 0 , '');

usage()
  unless GetOptions(
  "paligs=s" => \$opt_paligs,
  "s=s"      => \$opt_s,
  "n=i"      => \$opt_n,
  "outc:s"   => \$opt_outc,
  "outw:s"   => \$opt_outw,
  "outl:s"   => \$opt_outl,
  "v"        => \$opt_v,
  '<>'       => \&usage
  );

if ( !$opt_paligs || !$opt_n || !$opt_s) {
  usage();
}

############################################################

# matrix of alignment "locality" info
# ij-entry contains: "center of i given that i and j align."
my @center;
for ( my $i = 0 ; $i < $opt_n ; $i++ ) {
  for ( my $j = 0 ; $j < $opt_n ; $j++ ) {
    $center[$i][$j] = 0.5; # default value
  }
}

# matrix of alignment-block-"widths"
# = percentage of coverage of sequence
# = how much of the sequence participates in the alignment-block
# ij-entry contains: coverage of i with respect to j
my @widths;
for ( my $i = 0 ; $i < $opt_n ; $i++ ) {
  for ( my $j = 0 ; $j < $opt_n ; $j++ ) {
    $widths[$i][$j] = 1;
  }
}

# matrix of locarna scores
my @scores;
for ( my $i = 0 ; $i < $opt_n ; $i++ ) {
  for ( my $j = 0 ; $j < $opt_n ; $j++ ) {
    $scores[$i][$j] = 0;
  }
}

my @files = glob("$opt_paligs/*.bz2");

#print join("\n", @files);

# read sequence lengths
my %seqLengths;
getSeqLengths(\%seqLengths, $opt_s);
#print Dumper %seqLengths;
#foreach my $k (sort {$a <=> $b} keys %seqLengths) {
#  print "$k $seqLengths{$k}\n";
#}

# loop thru alignment files
foreach my $f (@files) {
  print "file=$f\n" if ($opt_v);

  # returns array of hashes containing the alignments
  my @aln = getAlignments($f);

  # do something for each aln
  foreach my $a (@aln) {
    if ($opt_v) {

      print Dumper $a;
      print "ij = $a->{iid}, $a->{jid}\n";
    }

    # get center values
    my ( $center_i, $center_j ) = getCenter($a, \%seqLengths);

    # center of i with respect to j
    $center[ ( $a->{iid} - 1 ) ][ ( $a->{jid} - 1 ) ] = $center_i;

    # center of j with respect to i
    $center[ ( $a->{jid} - 1 ) ][ $a->{iid} - 1 ] = $center_j;

    # get coverage values
    my ( $width_i, $width_j ) = getWidths($a, \%seqLengths);

    $widths[ $a->{iid} - 1 ][ $a->{jid} - 1 ] = $width_i;
    $widths[ $a->{jid} - 1 ][ $a->{iid} - 1 ] = $width_j;

    # locarna scores
    $scores[ $a->{iid} - 1 ][ $a->{jid} - 1 ] = $a->{score};
    $scores[ $a->{jid} - 1 ][ $a->{iid} - 1 ] = $a->{score};
  }
}

# output matrices
printMatrix( $opt_outc, \@center );
printMatrix( $opt_outw, \@widths );
printMatrix( $opt_outl, \@scores );

############################################################

sub printMatrix {
  my ( $file, $m ) = @_;

  open OUT, "> $file" or die "ERROR: could not open outfile '$file";

  for ( my $i = 0 ; $i < scalar( @{$m} ) ; $i++ ) {
    print OUT join( ' ', @{ $m->[$i] } ), "\n";
  }

  close OUT;
}

# returns value for i and j
sub getWidths {
  my $a = shift; # hashref of the alignment
  my $s = shift; # hashref of seq lengths

  my ( $width_i, $width_j ) = ( -1, -1 );    # init

  die "ERROR: Broken pipeline, the ".$a->{iid}.".th seqs.fasta entry does not exist."if(! exists $s->{$a->{iid}});
  die "ERROR: Broken pipeline, the ".$a->{jid}.".th seqs.fasta entry does not exist."if(! exists $s->{$a->{jid}});

  $width_i = nearest( .0001, ($a->{iEnd}-$a->{iStart} +1 ) / $s->{$a->{iid}} );
  $width_j = nearest( .0001, ($a->{jEnd}-$a->{jStart} +1 ) / $s->{$a->{jid}} );

  if ($opt_v) {
    print "width_i=$width_i  (= ($a->{iEnd}-$a->{iStart}+1) / $s->{$a->{iid}}), ";
    print "width_j=$width_j  (= ($a->{jEnd}-$a->{jStart} +1) / $s->{$a->{jid}})\n";
  }

  die "ERROR: width can not be negative! (wi=$width_i, wj=$width_j)"
    if ( $width_i < 0 || $width_j < 0 );

  die "ERROR: width is undefined? (ci=$width_i, cj=$width_j)"
    if ( !defined $width_i || !defined $width_j );

  die "ERROR: width can not be >1 !! (wi=$width_i, wj=$width_j)"
    if ( $width_i > 1 || $width_j > 1 );

  return ( $width_i, $width_j );
}

# returns value for i and j
sub getCenter {
  my $a = shift; # hashref of the alignment
  my $s = shift; # hashref of seq lengths

  my ( $center_i, $center_j ) = ( -1, -1 );    # init

  die "ERROR: Broken pipeline, the ".$a->{iid}.".th seqs.fasta entry does not exist."if(! exists $s->{$a->{iid}});
  die "ERROR: Broken pipeline, the ".$a->{jid}.".th seqs.fasta entry does not exist."if(! exists $s->{$a->{jid}});

  $center_i = nearest( .0001, (($a->{iStart} + ($a->{iEnd}-$a->{iStart} +1 )/2)) / $s->{$a->{iid}} );
  $center_j = nearest( .0001, (($a->{jStart} + ($a->{jEnd}-$a->{jStart} +1 )/2)) / $s->{$a->{jid}} );
  if ($opt_v) {
    print "center_i=$center_i  (= (($a->{iStart} + ($a->{iEnd}-$a->{iStart} +1 )/2)) / $s->{$a->{iid}}), ";
    print "center_j=$center_j  (= (($a->{jStart} + ($a->{jEnd}-$a->{jStart} +1 )/2)) / $s->{$a->{jid}})\n";
  }

  die "ERROR: center can not be negative! (ci=$center_i, cj=$center_j)"
    if ( $center_i < 0 || $center_j < 0 );

  die "ERROR: center is undefined? (ci=$center_i, cj=$center_j)"
    if ( !defined $center_i || !defined $center_j );

  die "ERROR: center can not be >1 !! (ci=$center_i, cj=$center_j)"
    if ( $center_i > 1 || $center_j > 1 );

  return ( $center_i, $center_j );
}

# given a bz2 file
# get all alignments
sub getAlignments {
  my ($file) = @_;
  open( IN, "bunzip2 -c $file |" ) or die "Cannot read from $!";

  my %hash;     # track a single alignment
  my @array;    # put them in an array

  my $done = 0;

  while ( my $line = <IN> ) {

    #id score s e s e
     if ( $line =~ /^\@(\d+) Score: (-?\d+)/ ) {    #ID
      %hash         = ();
      $hash{id}     = $1;
     } elsif ( $line =~ /^HIT (-?\d+) (\d+) (\d+) (\d+) (\d+)/ ) {
      #if ( $line =~ /^\@(\d+) HIT (-?\d+) (\d+) (\d+) (\d+) (\d+)/ ) {
      $hash{score}  = $1;
      $hash{iStart} = $2;
      $hash{jStart} = $3;
      $hash{iEnd}   = $4;
      $hash{jEnd}   = $5;
      $hash{iid} = '';
      $hash{jid} = '';

      $done = 0;

    } elsif ( $done == 0 && $line =~ /^(\d+)\s+/ && $hash{iid} eq '') {
          $hash{iid}  = $1;
    } elsif ( $done == 0 && $line =~ /^(\d+)\s+/ && $hash{jid} eq '') {
          $hash{jid}  = $1;
	  $done = 1;
	   push @array, {%hash};    #store aln
    }
  }
  close IN;

  return @array;
}

# read in length of participating sequences
sub getSeqLengths {
  my $hashref = shift;
  my $file = shift;

  my $counter = 0;
  open( IN, "< $file " ) or die "Cannot read from $!";
  while ( <IN> ) {
    chomp $_;
    if($_=~/^([^>]\S+)$/) {
      $counter++;
      my $seq = $1;
      #print $seq, "\n";
      $hashref->{$counter} = length($seq);
    }
  }
  close IN;
}

sub usage {
  print STDERR $usage;
  exit;
}
