#!/usr/bin/perl -w

# FABRIZIO-style clustering approach
# take score-list from RNAclust and generate center and width matrices

use FindBin;
use lib "$FindBin::Bin";

use strict;
use Getopt::Long;
use Data::Dumper;
use Math::Round;

# contribution to local clustering
# create "center" and "width" matrix for local clustering
# these two features contribute to the overall score

my $usage = << "JUS";
  usage: perl $0 -paligs FILE -n INT -outc FILE -outw FILE

  options:
        -paligs
                directory of pairwise alignments, as generated by RNAclust
                [REQUIRED]

                Format:
                \@1
                Score: 1930
                2      GAAACAACUGCCAAGUGUUUUUUCUUACAACACAAAAUCUA
                1      ~UAACAGGACUCUUGUAUUUUCAUAUCCUUACUU~~~~~~~

        -n      Number of sequences in the screen
                [REQUIRED]

        -outl
                Output file containing the matrix of locarna scores
                [OPTIONAL, default: matrix.locarna]

        -outc
                Output file containing the matrix of centers
                [OPTIONAL, default: matrix.centers]

        -outw
                Output file containing the matrix of widths
                [OPTIONAL, default: matrix.widths]

        -v
                Switch to turn on verbose mode
                [OPTIONAL, default: off]

  purpose: create feature matrices
JUS

my ( $opt_paligs, $opt_n, $opt_outc, $opt_outw, $opt_outl, $opt_v ) =
  ( '', 0, 'matrix.centers', 'matrix.widths', 'matrix.locarna', 0 );

usage()
  unless GetOptions(
  "paligs=s" => \$opt_paligs,
  "n=i"      => \$opt_n,
  "outc:s"   => \$opt_outc,
  "outw:s"   => \$opt_outw,
  "outl:s"   => \$opt_outl,
  "v"        => \$opt_v,
  '<>'       => \&usage
  );

if ( !$opt_paligs || !$opt_n ) {
  usage();
}

############################################################

# matrix of alignment "locality" info
# ij-entry contains: "center of i given that i and j align."
my @center;
for ( my $i = 0 ; $i < $opt_n ; $i++ ) {
  for ( my $j = 0 ; $j < $opt_n ; $j++ ) {
    $center[$i][$j] = 0.5; # default value
  }
}

# matrix of alignment-block-"widths"
# = percentage of coverage of sequence
# = how much of the sequence participates in the alignment-block
# ij-entry contains: coverage of i with respect to j
my @widths;
for ( my $i = 0 ; $i < $opt_n ; $i++ ) {
  for ( my $j = 0 ; $j < $opt_n ; $j++ ) {
    $widths[$i][$j] = 1;
  }
}

# matrix of locarna scores
my @scores;
for ( my $i = 0 ; $i < $opt_n ; $i++ ) {
  for ( my $j = 0 ; $j < $opt_n ; $j++ ) {
    $scores[$i][$j] = 0;
  }
}

my @files = glob("$opt_paligs/*.bz2");

#print join("\n", @files);

# loop thru alignment files
foreach my $f (@files) {
  print "file=$f\n" if ($opt_v);

  # returns array of hashes containing the alignments
  my @aln = getAlignments($f);

  # do something for each aln
  foreach my $a (@aln) {
    if ($opt_v) {

      print Dumper $a;
      print "i: $a->{iSeq}\nj: $a->{jSeq}\n";
      print "ij = $a->{iid}, $a->{jid}\n";
    }

    # get center values
    my ( $center_i, $center_j ) = getCenter($a);

    # center of i with respect to j
    $center[ ( $a->{iid} - 1 ) ][ ( $a->{jid} - 1 ) ] = $center_i;

    # center of j with respect to i
    $center[ ( $a->{jid} - 1 ) ][ $a->{iid} - 1 ] = $center_j;

    # get coverage values
    my ( $width_i, $width_j ) = getWidths($a);

    $widths[ $a->{iid} - 1 ][ $a->{jid} - 1 ] = $width_i;
    $widths[ $a->{jid} - 1 ][ $a->{iid} - 1 ] = $width_j;

    # locarna scores
    $scores[ $a->{iid} - 1 ][ $a->{jid} - 1 ] = $a->{score};
    $scores[ $a->{jid} - 1 ][ $a->{iid} - 1 ] = $a->{score};
  }
}

# output matrices
printMatrix( $opt_outc, \@center );
printMatrix( $opt_outw, \@widths );
printMatrix( $opt_outl, \@scores );

############################################################

sub printMatrix {
  my ( $file, $m ) = @_;

  open OUT, "> $file" or die "ERROR: could not open outfile '$file";

  for ( my $i = 0 ; $i < scalar( @{$m} ) ; $i++ ) {
    print OUT join( ' ', @{ $m->[$i] } ), "\n";
  }

  close OUT;
}

# returns value for i and j
sub getWidths {
  my $a = shift;    # hashref of the alignment

  my ( $width_i, $width_j ) = ( -1, -1 );    # init

  $width_i = nearest( .0001, length( $a->{iSeqOfBlock} ) / $a->{iSeqLen} );
  $width_j = nearest( .0001, length( $a->{jSeqOfBlock} ) / $a->{jSeqLen} );

  if ($opt_v) {
    print "width_i=$width_i  (=" . ( length( $a->{iSeqOfBlock} ) . "/" . $a->{iSeqLen} ) . "), ";
    print "width_j=$width_j  (=" . ( length( $a->{jSeqOfBlock} ) . "/" . $a->{jSeqLen} ) . ")\n";
  }

  die "ERROR: width can not be negative! (wi=$width_i, wj=$width_j)"
    if ( $width_i < 0 || $width_j < 0 );

  die "ERROR: width is undefined? (ci=$width_i, cj=$width_j)"
    if ( !defined $width_i || !defined $width_j );

  die "ERROR: width can not be >1 !! (wi=$width_i, wj=$width_j)"
    if ( $width_i > 1 || $width_j > 1 );

  return ( $width_i, $width_j );
}

# returns value for i and j
sub getCenter {
  my $a = shift;    # hashref of the alignment

  my ( $center_i, $center_j ) = ( -1, -1 );    # init

  my $iCenterOfBlock = round( length( $a->{iSeqOfBlock} ) / 2 ) + $a->{iNoOfUpstreamLostNt};
  my $jCenterOfBlock = round( length( $a->{jSeqOfBlock} ) / 2 ) + $a->{jNoOfUpstreamLostNt};

  $center_i = nearest( .0001, $iCenterOfBlock / $a->{iSeqLen} );
  $center_j = nearest( .0001, $jCenterOfBlock / $a->{jSeqLen} );

  if ($opt_v) {
    print "center_i=$center_i  (=$iCenterOfBlock/$a->{iSeqLen}), ";
    print "center_j=$center_j  (=$jCenterOfBlock/$a->{jSeqLen})\n";
  }

  die "ERROR: center can not be negative! (ci=$center_i, cj=$center_j)"
    if ( $center_i < 0 || $center_j < 0 );

  die "ERROR: center is undefined? (ci=$center_i, cj=$center_j)"
    if ( !defined $center_i || !defined $center_j );

  die "ERROR: center can not be >1 !! (ci=$center_i, cj=$center_j)"
    if ( $center_i > 1 || $center_j > 1 );

  return ( $center_i, $center_j );
}

# given a bz2 file
# get all alignments
# be careful: alignments can be over multiple lines!
sub getAlignments {
  my ($file) = @_;
  open( IN, "bunzip2 -c $file |" ) or die "Cannot read from $!";

  my %hash;     # track a single alignment
  my @array;    # put them in an array

  my $first        = 1;
  my $qtEmptyLines = 0;

  while ( my $line = <IN> ) {
    if ( $line =~ /^\@(\d+) Score: (-?\d+)/ ) {    #ID
      %hash        = ();
      $hash{id}    = $1;
      $hash{score} = $2;
      $first       = 1;
    } elsif ( $line =~ /^(\d+)\s+(\S+)/ ) {
      if ($first) {                              # i.th entry
        if ( !exists $hash{iid} ) {              # init
          $hash{iid}  = $1;
          $hash{iSeq} = $2;
        } else {                                 # enlarge
          $hash{iSeq} .= $2;
        }
        $first = 0;
      } elsif ( $line =~ /^(\d+)\s+(\S+)/ ) {
        if ( !exists $hash{jid} ) {              # j.th entry
          $hash{jid}  = $1;
          $hash{jSeq} = $2;
        } else {
          $hash{jSeq} .= $2;
        }
        $first        = 1;
        $qtEmptyLines = 0;

      }
    } else {
      $qtEmptyLines++;

      # here we have all data
      if ( $qtEmptyLines == 2 && exists $hash{jid} ) {

        # set additional values
        # get aln start...
        if ( $hash{iSeq} =~ /^(\~+)([^\~]+)/ || $hash{jSeq} =~ /^(\~+)([^\~]+)/ ) {
          $hash{alnStartCol} = ( length $1 ) + 1;
        } else {
          $hash{alnStartCol} = 1;
        }

        # ... and end
        if ( $hash{iSeq} =~ /([^\~]+)(\~+)$/ || $hash{jSeq} =~ /([^\~]+)(\~+)$/ ) {
          $hash{alnEndCol} = ( length $hash{iSeq} ) - length $2;
        } else {
          $hash{alnEndCol} = ( length $hash{iSeq} );
        }

        # get length of pure sequences (without gaps)
        my $tmp = $hash{iSeq};
        $tmp =~ s/[-~]//g;
        $hash{iSeqLen} = length $tmp;

        $tmp = $hash{jSeq};
        $tmp =~ s/[-~]//g;
        $hash{jSeqLen} = length $tmp;

        #my %iMap;    # maps of aln-position vs seq-position
        #my %jMap;
        #my ( $iValidNt, $jValidNt ) = ( 0, 0 );    # pos of seq
        #my @i = split //, $hash{iSeq};
        #my @j = split //, $hash{jSeq};
        #for ( my $k = 0 ; $k < scalar(@i) ; $k++ ) {    # pos of alignment
        #  if ( $i[$k] !~ /[\~\-]/ ) {
        #    $iValidNt++;
        #    $iMap{ $k + 1 } = $iValidNt;
        #  }
        #}
        #for ( my $k = 0 ; $k < scalar(@j) ; $k++ ) {    # pos of alignment
        #  if ( $j[$k] !~ /[\~\-]/ ) {
        #    $jValidNt++;
        #    $jMap{ $k + 1 } = $jValidNt;
        #  }
        #}
        #$hash{iMap} = {%iMap};
        #$hash{jMap} = {%jMap};

        # get seq without gaps of alignment-block
        $hash{iSeqOfBlock} = substr $hash{iSeq}, $hash{alnStartCol} - 1,
          $hash{alnEndCol} - $hash{alnStartCol} + 1;
        $hash{iSeqOfBlock} =~ s/[\-\~]//g;

        $hash{jSeqOfBlock} = substr $hash{jSeq}, $hash{alnStartCol} - 1,
          $hash{alnEndCol} - $hash{alnStartCol} + 1;
        $hash{jSeqOfBlock} =~ s/[\-\~]//g;

        # number of upstream nt that are not part of the alignment block
        $hash{iNoOfUpstreamLostNt} = substr $hash{iSeq}, 0, $hash{alnStartCol} - 1;
        $hash{iNoOfUpstreamLostNt} =~ s/[\~\-]//g;
        $hash{iNoOfUpstreamLostNt} = length $hash{iNoOfUpstreamLostNt};

        $hash{jNoOfUpstreamLostNt} = substr $hash{jSeq}, 0, $hash{alnStartCol} - 1;
        $hash{jNoOfUpstreamLostNt} =~ s/[\~\-]//g;
        $hash{jNoOfUpstreamLostNt} = length $hash{jNoOfUpstreamLostNt};

        push @array, {%hash};    #store aln
      }
    }
  }
  close IN;

  # quality checks
  my $l1 = length $hash{iSeq};
  my $l2 = length $hash{jSeq};
  if ( $l1 != $l2 ) {
    die "ERROR: aligned sequences do not have the same lengths! ($l1 vs $l2)";
  }

  return @array;
}

sub usage {
  print STDERR $usage;
  exit;
}
